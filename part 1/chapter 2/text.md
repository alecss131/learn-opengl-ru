# Часть 1.2 — Создание окна

Прежде чем начать создавать умопомрочительную графику нам надо создать контекст и окно приложения, в котором мы будет эту графику рисовать. Но, к сожалению, эти операции специфичны для каждой операционной системы и OpenGL всеми силами старается абстрагироваться от этих операций. Это означает, что создавать окно, определять контекст и работать с пользовательским вводом нам придется самим.

## GLFW

GLFW — это библиотека, написанная на C, специально нацеленная для предоставления OpenGL самого необходимого для отрисовки контента на экран. Она позволяет нам создать контекст, определить параметры окна и работать с пользовательским вводом, а это все что там сейчас нужно.

В основном в этом и следующем уроке мы будем заставлять GLFW нормально работать, проверять правильность создания OpenGL контекста и производить отрисовку окна в котором мы будет рисовать графику. Этот урок пошагово расскажет о сборке и линковке GLFW библиотеки. Для этого урока мы будем использовать Microsoft Visual Studio 2012 \(заметьте, что процесс будет мало отличаться для других версий VS\). Если вы не используете VS — то не волнуйтесь, этот процесс очень похож для всех IDE.

### Сборка GLFW

GLFW можно скачать со страницы загрузки официального [сайта](http://www.glfw.org/download.html). GLFW поставляется с прекомпилированными бинарниками и заголовочными файлами для VS, но для полноты картины мы соберем GLFW собственноручно. Так что давайте скачаем пакет с исходным кодом \(Source package\).

> Если вы используете прекомпилированные бинарники — удостоверьтесь, что вы скачали 32 битную версию, а не 64 битную. \(Если вы не знаете в чем существенная разница\). Так как 64 битная версия генерирует довольно странное поведение для большинства читателей.

После того, как вы скачаете пакет — разархивируйте его. Нам интересны следующие элементы:

- Результат компиляции
- Папка **include**

Сборка библиотеки из исходного кода гарантирует, что результирующая библиотека будет идеально работать на вашем CPU/OS, чего нельзя сказать про поставляемые прекомпилированные библиотеки \(иногда они даже просто недоступны для вашей системы\). Основная проблема предоставления исходного кода миру, что далеко не все используют одну и ту же IDE для разработки их приложения, что означает, что Проектные файлы могут быть просто несовместимы с другими IDE. И из за этого людям приходится руками собирать собственные проекты, что, очевидно, не очень удобно. Специально для того, чтобы избежать этой проблемы был придуман CMake.

### CMake

CMake — это инструмент для генерации файлов Проекта/Решения для IDE, выбранного пользователем \(Visual Studio, Code::Blocks, Eclipse\) из набора исходных кодов и CMake скриптов. Такая конфигурация позволяет сгенерировать Visual Studio 2012 проектные файлы, чтобы мы могли без труда собрать библиотеку. Для начала нам надо скачать CMake, сделать это можно на странице [загрузки](http://www.cmake.org/cmake/resources/software.html). Я использую Win32 установщик.

Как только CMake установится, вы сможете выбрать запуск CMake из консоли или в качестве графического приложения. Так как мы стараемся не перегружать уроки — то мы выберем графическое приложение. CMake требует указать директорию с исходным кодом и папку, куда будет записан результат в виде бинарных файлов. В качества директории с исходным кодом мы укажем корневую папку разархивированного GLFW пакета с исходным кодом, а в качестве папки для бинарных файлов мы укажем новую директорию *<build*.

![](https://github.com/loginmen/learnopengl/blob/master/part%201/chapter%202/1.png)

После установки требуемых директорий, нажмите **Configure**, что бы CMake считал требуемые настройки и исходный код. Затем нам требуется выбрать генератор для проекта. Так как мы собираемся использовать Visual Studio 2012 мы выбираем Visual Studio 11 \(Visual Studio 2012 также известна как Visual Studio 11\). Далее CMake отобразит возможные настройки сборки, их можно оставить без изменения, нажав еще раз на **Configure** для их сохранения. После сохранения настроек можем приступать к генерации проекта, для этого нажмите на **Generate** и в папке **build** будут созданы файлы проекта.

### Компиляция

В папке **build** появился файл **GLFW.sln**, открываем его Visual Studio. CMake должен был сгенерировать проект со всеми требуемыми настройками, поэтому просто начинаем сборку, нажимая на **Build Solution** и в качестве результата мы получае **glfw3.lib** \(мы используем 3 версию\) в папке **src/Debug**.

После того, как библиотека сгенерировалась надо удостовериться, что IDE знает где искать библиотеку и заголовочные файлы. Есть 2 способа сделать это:

1. Мы ищем **/lib** и **/include** папки IDE или Компилятора и добавляем туда папку **include** и **lib** из GLFW. Это будет работать, но так лучше не делать. Такой метод сложно отследить и вы потеряете все файлы при переустановке или смене компилятора/IDE.

2. Рекомендованный способ — это создать набор директорий, содержащие все заголовочные файлы и библиотеки от третьих лиц к которым вы могли бы обращаться при использовании вашего IDE или Компилятора. Лично я использую одну папку, содержащую папки **Libs** и **Include** где я храню все свои заголовочные файлы и библиотеки для OpenGL проектов. Теперь все мои библиотеки от третьих лиц собраны в одном месте \(и их легко перемещать между разными PC\). Единственный недостаток — необходимость для каждого нового проекта указывать местоположение этой папки.

По завершению выбранного вами действия можно перейти к созданию нашего первого OpenGL проекта с GLFW.

## Наш первый проект

Для начала давайте откроем Visual Studio и создадим новый проект. Выберите Visual C++ и Пустой проект \(не забудьте выдать проекту приемлемое имя\). Теперь у нас есть рабочее пространство для создания нашего первого приложения с использованием OpenGL.

### Линковка

Для использования GLFW нам также требуется его связать с нашим проектом. Это делаеться, указанием, что мы хотим использовать **glfw3.lib** в настройках линковщика, но наш проект все еще не знает, где искать **glfw3.lib** \(если вы не выбрали 1 вариант во время решения проблемы с местонахождением файлов библиотек\), соответственно нам надо добавить эти директории в проект.

Мы можем добавить те директории, для этого перейдите в **VC++ Directories**, как показано на изображении ниже:

![](https://github.com/loginmen/learnopengl/blob/master/part%201/chapter%202/2.png)

И оттуда вы можете добавить собственные директории, чтобы проект знал где искать требуемые файлы. Это можно сделать ручным способом, просто вставив путь в текстовое поле, либо нажав на **Edit...**, где вы сможете добавить значения в специальном окне.

![](https://github.com/loginmen/learnopengl/blob/master/part%201/chapter%202/3.png)

Здесь вы можете добавить такое количество директорий, какое вам захочется, а IDE также будет искать требуемые файлы там. Теперь, когда **Include** папка указана для среды вы сможете найти все требуемые заголовочные файлы GLFW в <GLFW/..>. Тоже самое применимо и для директории с библиотеками.

И уже после того, как Visual Studio узнал, где искать требуемые библиотеки, мы наконец можем связать GLFW и наш проект:

![](https://github.com/loginmen/learnopengl/blob/master/part%201/chapter%202/4.png)

Здесь требуется указать название линкуемой библиотеки, в нашем случае это **glfw3.lib** и добавляем мы ее в поле **Additional Dependencies** \(сделать это также можно изменив руками или использовав кнопку **<Edit…>**\) и теперь GLFW будет линковаться к проекту во время компиляции. Также требуется указать OpenGL библиотеки, но этот процесс отличается для разных ОС.

### OpenGL библиотека для Windows

Если вы используете Windows — то библиотека, называющаяся **opengl32.lib** поставляется с Microsoft SDK, которая ставится по умолчанию при установке Visual Studio. Так как в этом уроке мы и так использует Visual Studio — то здесь будет достаточно просто добавить **opengl32.lib** в настройки линковщика.

### OpenGL библиотека для Linux

На Linux системах вам требуется использовать **libGL.so** библиотеку, использовав флаг **-lGL** в настройках линковщика. Если вы не можете найти эту библиотеку — то вам, вероятно, требуется поставить Mesa, NVidia или AMD dev пакеты, но я не буду вдаваться в подробности, так как это очень специфично для платформы \(плюс я не являюсь Linux экспертом\).

По окончанию добавления GLFW и OpenGL библиотеки в настройки линковщика вы можете подключать GLFW следующим образом:

```cpp
#include <GLFW\glfw3.h>
```

Это финальный этап установки и настройки OpenGL.

## GLEW

Но мы еще не закончили с настройкой OpenGL. Кое что еще придется сделать. Поскольку OpenGL — это лишь спецификация — то реализация ложится на плечи разработчиков видеокарт. По этой причине, поскольку существует множество реализаций OpenGL реальное расположение OpenGL функций не доступно на этапе компиляции и их приходится получать на этапе исполнения. Фактически получение адресов функций ложится на плечи программиста. Процесс получения адресов специфичес для каждой платформы, для Windows это выглядит примерно так:

```cpp
// Определяем прототип функции
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// Находим эту функцию в реализации и сохраняем указатель на нее
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
// Теперь мы можем нормально вызвать эту функцию
GLuint buffer;
glGenBuffers(1, &buffer);
```

Как вы можете заметить код выглядит довольно запутанным, а необходимость производить получение адреса для каждой OpenGL функции делает этот процесс просто мучительным. Но к счастью существуют библиотеки реализующие эту динамическую линковку и одной из самых популярных библиотек является **GLEW**

### Сборка и линковка GLEW

GLEW расшифровывается как OpenGL Extension Wrangler Library и управляем всей той громоздкой работой о которой говорилось выше. Поскольку GLEW это тоже библиотека — то нам опять придется собрать ее и связать с нашим проектом. GLEW может быть скачан с официальной [страницы](http://glew.sourceforge.net/index.html), там вы найдете как уже прекомпилированные библиотеки, так и исходный код. И опять же повторюсь: если вы не уверены какую битность использовать — используйте 32 битную версию.

Мы будем использовать статическую версию GLEW, которая называется **glew32s.lib** \(заметьте приставку *s*\). Поэтому добавьте ее в вашу папку с библиотеками, а также добавьте заголовочные файлы в вашу папку с заголовочными файлами. Теперь мы можем линкануть GLEW к проекту, добавив **glew32s.lib** в настройки линковщика в Visual Studio. Заметьте, что GLFW3 по умолчанию собирается как статическая библиотека.

> **Статическая** линковка означает, что библиотека будет интегрирована с исполняемым файлом во время компиляции. Преимущество такого подхода в том, что вам не нужно следить за дополнительными файлами, помимо исполняемого файла. Недостатки такого подхода состоят в том, что исполняемый файл увеличивается в размерах и что при обновлении библиотеки вы вынуждены пересобирать исполняемый файл.

> **Динамическая** линковка осуществляется посредством .dll и .so файлов, осуществляя разделение кода библиотеки и кода приложения, уменьшая размер исполняемого файла и упрощая обновление библиотеки. Недостатком такого подхода является тот факт, что вам придется выпускать DLL файлы вместе с финальным приложением.

Если вы хотите использовать GLEW как статическую библиотеку — то перед подключением GLEW следует задать переменную препроцессора **GLEW_STATIC**.

```cpp
#define GLEW_STATIC
#include <GL/glew.h>
```

Если вы хотите динамическое связывание — то вы можете опустить задачу переменной препроцессора GLEW_STATIC. Помните, что если вы используете динамическое связывание то вам придется скопировать .DLL файл в папку с исполняемым файлом.

>Для пользователей Linux, собирающих проект с помощью GCC в сборке могут помочь следующие ключи:
>-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi.
>Неправильное использование данных ключей может привести к большому количеству неопределенного поведения.


Теперь, когда мы наконец то собрали и связали GLFW и GLEW у нас все готово для следующего урока в котором мы обсудим как использовать GLFW и GLEW для настройки OpenGL контекста и создания окна. Удостоверьтесь, что ваши директории с заголовочными файлами и файлами библиотек указаны верно и что в названиях библиотек в настройках линковщика нет ошибок. Если вы застряли — проверьте комментарии к исходной статье или другие источники, возможно вы допустили некоторую специфическую ошибку.

## Дополнительные ресурсы

- [Сборка приложений](http://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/): предоставляет подробную информацию о процессе линковки и компиляции приложения с большим количеством различных возможных ошибок;
- [GLFW с Code::Blocks](http://wiki.codeblocks.org/index.php?title=Using_GLFW_with_Code::Blocks): сборка GLFW в Code::Blocks IDE;
- [Запуск CMake](http://www.cmake.org/runningcmake/): небольшой урок о запуске CMake под Windows и Linux;
- [Написание сборочной системы под Linux](http://learnopengl.com/demo/autotools_tutorial.txt): урок по autotools от Wouter Verholds описывающий процесс написания системы сборки в Linux специально настроенных для этих уроков;
- [Polytonic/Glitter](https://github.com/Polytonic/Glitter): простой шаблонный проект, который поставляется пред-настроенным со всемы требуемыми библиотеками; идеален, если вы хотите увидеть пример полностью работающего LearnOpenGL проекта.
