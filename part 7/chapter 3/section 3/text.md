# Рендер Спрайтов

Чтобы вдохнуть немного жизни в черную бездну нашего игрового мира, мы нарисуем спрайты, чтобы заполнить пустоту. Спрайт имеет много определений, но фактически это не более чем 2D изображение, используемое вместе с некоторыми данными, чтобы позиционировать его в большом мире \(т.е. позиция, вращение, и масштаб\). В основном, спрайты это изображения\/текстурные объекты которые мы используем в 2D играх.

Мы можем, как и в предыдущих главах, создать двухмерную форму из данных о вершинах, передать все данные в GPU и преобразовать их вручную. Однако, в более крупном приложении, как это, мы скорее имеем некоторые абстракции по рендерингу 2D-фигур. Если мы вручную определим эти формы и преобразования для каждого объекта, это быстро превратиться в бардак.

В этой главе мы определим класс рендеринга, который позволит нам создавать большое количество уникальных спрайтов с минимальным количеством кода. Таким образом, мы как бы отделяем \(делаем абстрактным\) код геймплея от кода Opengl, как это обычно делается в больших проектах. Пернвое, что мы должны сделать - это установить правильную матрицу проекции.

## 2D матрица проекции

Мы знаем из главы [cистема координат](../../../part%201/chapter%208/text.md), что матрица проекции преобразует все координаты view-space в clip-space \(а затем в нормализованное устройство\) координаты. Создавая соответствующую проекционную матрицу, мы можем работать с различными координатами, с которыми проще работать, по сравнению с прямым определением всех координат в качестве нормализованных координат устройства.

Нам не нужно использовать никакую перспеутиву относительно координатного пространства, так как игра полностью в 2D, так что орфографическая проекционная матрица подходит для рендеринга довольно хорошо. Поскольку орфографическая проекционная матрица непосредственно преобразует все координаты в нормализованные координаты устройства, мы можем выбрать определение мировых координат в качестве координат экрана, определяя проекционную матрицу следующим образом:

```cpp
glm::mat4 projection = glm::ortho(0.0f, 800.0f, 600.0f, 0.0f, -1.0f, 1.0f);  
```

Первые четыре аргумента определяют порядок левой, правой, нижней и верхней части проекции. Эта проекционная матрица преобразует все координаты х от 0 до 800 в -1 и 1, и все координаты у от 0 до 600 в -1 и 1. Здесь необходимо уточнить, что верхняя часть имеет координату у = 0, в то время как нижняя часть имеет координату у = 600. В результате верхняя левая координата сцены будет равна \(0,0\), а нижняя правая часть экрана - координате \(800,600\), как и координаты экрана; мировые координаты непосредственно соответствуют результирующим координатам пикселей.

![](0.png)

Это позволяет нам указать все координаты вершин, равные координатам пикселя, которые они получают на экране, что довольно интуитивно для 2D-игр.

## Рендер спрайтов

Рендер реального спрайта не должен быть слишком сложным. Мы создаем текстурированный квад, который мы можем преобразовать в матрицу модели, после чего мы проецируем его с помощью ранее определенной орфографической проекционной матрицы.

> Так как Арканоид является игрой с одной сценой, нет необходимости в матрице просмотра\/камеры. Используя матрицу проекции, мы можем напрямую преобразовать мировые координаты в нормализованные координаты устройства.

Чтобы преобразовать спрайт, мы используем следующий вершинный шейдер:
```glsl
#version 330 core
layout (location = 0) in vec4 vertex; // <vec2 position, vec2 texCoords>

out vec2 TexCoords;

uniform mat4 model;
uniform mat4 projection;

void main()
{
    TexCoords = vertex.zw;
    gl_Position = projection * model * vec4(vertex.xy, 0.0, 1.0);
}
```

Обратите внимание, что мы храним данные о местоположении и текстурной-координате в одной переменной *vec4*. Поскольку координаты положения и текстуры содержат две переменных float, мы можем объединить их в один атрибут вершины.

Фрагментный шейдер также относительно прост. Мы берём текстуру и вектор цвета, которые влияют на окончательный цвет фрагмента. Имея единый вектор цвета, мы можем легко изменить цвет спрайтов из игрового кода:

```glsl
#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D image;
uniform vec3 spriteColor;

void main()
{    
    color = vec4(spriteColor, 1.0) * texture(image, TexCoords);
}  
```

Чтобы сделать рендеринг спрайтов более простым, мы определяем класс *Spriterenderer* который способен отображать спрайт только с одной функцией. Ее определение заключается в следующем:

```cpp
class SpriteRenderer
{
    public:
        SpriteRenderer(Shader &shader);
        ~SpriteRenderer();

        void DrawSprite(Texture2D &texture, glm::vec2 position, 
            glm::vec2 size = glm::vec2(10.0f, 10.0f), float rotate = 0.0f, 
            glm::vec3 color = glm::vec3(1.0f));
    private:
        Shader       shader; 
        unsigned int quadVAO;

        void initRenderData();
};
```

Класс Spriterenderer содержит объект шейдера, объект массива вершин и функцию визуализации и инициализации. Его конструктор использует объект шейдера, который в свою очередь используется для всей последующей отрисовки.

### Инициализация

Во-первых, давайте более детально рассмотрим функцию *initRenderData* которая настраивает quadVAO:

```cpp
void SpriteRenderer::initRenderData()
{
    // configure VAO/VBO
    unsigned int VBO;
    float vertices[] = { 
        // pos      // tex
        0.0f, 1.0f, 0.0f, 1.0f,
        1.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 0.0f, 
    
        0.0f, 1.0f, 0.0f, 1.0f,
        1.0f, 1.0f, 1.0f, 1.0f,
        1.0f, 0.0f, 1.0f, 0.0f
    };

    glGenVertexArrays(1, &this->quadVAO);
    glGenBuffers(1, &VBO);
    
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindVertexArray(this->quadVAO);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);  
    glBindVertexArray(0);
}
```

Здесь мы сначала определяем множество вершин с координатами \(0,0\) в качестве верхнего левого угла квада. Это означает, что когда мы делаем перевод или масштабирование преобразований на квадрат, они трансформируются из верхнего левого положения квадрата. Это обычная практика в системах 2D графики и\/или GUI, где позиции элементов соответствуют верхнему левому углу элементов.

Далее мы просто отправляем вершины в GPU и настраиваем их атрибуты, которые в данном случае являются атрибутом одной вершины. Нам нужно только определить один VAO для рендера спрайтов, так как все спрайты имеют одинаковые вершинные данные.

### Рендеринг

Рендеринг спрайтов не слишком труден; мы используем шейдер спрайтового рендера, настраиваем модель матрицы и устанавливаем соответствующую юниформу. Здесь важен порядок преобразований:

```cpp
void SpriteRenderer::DrawSprite(Texture2D &texture, glm::vec2 position, 
  glm::vec2 size, float rotate, glm::vec3 color)
{
    // prepare transformations
    this->shader.Use();
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(position, 0.0f));  

    model = glm::translate(model, glm::vec3(0.5f * size.x, 0.5f * size.y, 0.0f)); 
    model = glm::rotate(model, glm::radians(rotate), glm::vec3(0.0f, 0.0f, 1.0f)); 
    model = glm::translate(model, glm::vec3(-0.5f * size.x, -0.5f * size.y, 0.0f));

    model = glm::scale(model, glm::vec3(size, 1.0f)); 
  
    this->shader.SetMatrix4("model", model);
    this->shader.SetVector3f("spriteColor", color);
  
    glActiveTexture(GL_TEXTURE0);
    texture.Bind();

    glBindVertexArray(this->quadVAO);
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glBindVertexArray(0);
}  
```

При попытке позиционировать объекты где-то в сцене с вращением и масштабированием, рекомендуется сначала произвести масштабирование, затем повернуть и, наконец, передать объект. Поскольку умножение матриц происходит справа налево, мы преобразуем матрицу в обратном порядке: переводим, вращаем, а затем масштабируем.

Трансформация вращения может все еще казаться немного пугающей. Мы знаем по главе [преобразованиям](../../../part%201/chapter%208/text.md), что вращения всегда вращаются вокруг точки координат \(0,0\). Поскольку мы определили вершины квада с \(0,0\) в качестве левой-верхней координаты, все вращения будут именно в этой точке \(0,0\). Источник вращения находится в левом верхнем углу четырехугольника, что приводит к нежелательным результатам. Мы хотим переместить источник вращения в центр четырехугольника так, чтобы он аккуратно вращался вокруг этого источника, вместо вращения вокруг левого верха четырехугольника. Мы решаем эту задачу путём перевода четырехугольника на половину его размера первым, так что его центр находится в координате \(0,0\) перед вращением.

![](1.png)

С того момента как мы впервые смасштабировали четырехугольник, мы должны учитывать размер спрайта при переводе в центр, поэтому мы умножаем на вектор размера спрайта. Как только происходит трансформация вращения, мы делаем обратное преобразование.

Комбинируя все эти преобразования, мы можем позиционировать, масштабировать и вращать каждый спрайт так, как нам нравится. Ниже приведен полный исходный код спрайтового рендерера:

- SpriteRenderer: [header](sprite_renderer.h), [code](sprite_renderer.cpp)

## Привет Спрайт

С классом *Spriterenderer* мы, наконец, имеем возможность выводить фактические изображения на экран! Давайте инициализируем один в игровом коде и загрузим нашу любимую [текстуру](awesomeface.png):

```cpp
SpriteRenderer  *Renderer;
  
void Game::Init()
{
    // load shaders
    ResourceManager::LoadShader("shaders/sprite.vs", "shaders/sprite.frag", nullptr, "sprite");
    // configure shaders
    glm::mat4 projection = glm::ortho(0.0f, static_cast<float>(this->Width), 
        static_cast<float>(this->Height), 0.0f, -1.0f, 1.0f);
    ResourceManager::GetShader("sprite").Use().SetInteger("image", 0);
    ResourceManager::GetShader("sprite").SetMatrix4("projection", projection);
    // set render-specific controls
    Renderer = new SpriteRenderer(ResourceManager::GetShader("sprite"));
    // load textures
    ResourceManager::LoadTexture("textures/awesomeface.png", true, "face");
}
```

Затем в рамках функции рендеринга мы можем сделать наш любимый талисман, чтобы увидеть, работает ли все так, как должно:

```cpp
void Game::Render()
{
    Renderer->DrawSprite(ResourceManager::GetTexture("face"), 
        glm::vec2(200.0f, 200.0f), glm::vec2(300.0f, 400.0f), 45.0f, glm::vec3(0.0f, 1.0f, 0.0f));
}  
```

Здесь мы размещаем спрайт несколько ближе к центру экрана с его высотой чуть больше его ширины. Мы также поворачиваем его на 45 градусов и задаём зелёный цвет. Хочется отметить, что положение, которое мы задаем спрайту, равно левой верхней вершине четырехугольника.

Если вы все сделали правильно, вы должны получить следующий результат:

![](2.png)

Вы можете найти исходный код обновленного игрового класса [здесь](game.cpp).

Теперь, когда система рендеринга работает, мы можем использовать ее в [следующей главе](../../chapter%203/section%204/text.md), где мы будем работать над построением уровней игры.
